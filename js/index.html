<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- замыкание, this, асинхронное программирование, наследование, итераторы генераторы(по желанию), Storage, DOM -->

    <!-- ПРОТОТИП -->
    <!-- прототип это объект который присутствует у объектов и он вызывается по цепочке сверху вниз
     т.е мы находим какие-то поля на верхнем уровне или функции, мы обращаемся к ним, если не находим, то мы идем вниз по прототипу и ищем либо поля либо функции -->

    <!-- this, call, bind, aply -->
    <!-- this-Ключевое слово this всегда динамичное, оно указывает на тот объект в контексте которого оно было вызвано

bind-функция bind - в качестве значения этой функции му можем передать тот контекст который будет привязан у вызываемой функции
bind-метод bind на самом деле не вызывает функцию, а возвращает новую функцию которая уже привязала к себе новый контекст
bind-С помощью метода bind, помимо того что первым параметром мы указываем контекст который должен быть привязан к новой функции, 
    другими параметрами мы можем передавать следующие параметры которые нужны функции

group-метод group у объекта console

call-Метод call. Отличие от метода bind, что он метод call сразу же вызывает эту функцию,
    а метод bind в свою очередь возвращает нам новую функцию, и её мы можем вызвать тогда, когда нам угодно

apply-Метод apply. В отличие от методов bind и call, где можно бесконечное число параметров, 
    в метод apply мы всегда передаем два параметра. 

apply-У метода apply второй параметр всегда массив, и этот массив состоит из аргументов которые попадут в эту функцию.
Метод apply сразу же вызывает эту функцию. -->

    <!-- Замыкание -->

    <!-- Замыкание- функция внутри функции -->

    <!-- Асинхронность, SetTimeout, EventLoop -->

    <!-- SetTimeout - браузерный API (правильно вызывать SetTimeout: window.SetTimeout...) -->
    <!-- EventLoop - сначала идет в Call Stack, затем Wep API дальше в очередь Callbak Queue и в конце опять возвращается в Call Stack -->

    <!-- Promise -->
    <!-- Promise - по сути это обертка над асинхронностью, которую добавляет удобство для написания кода
then - тогда. В промисе колбэк-функция -> resolve (разрешить) -> then(тогда) ->... -->

    <!-- Объекты -->
    <!-- Object.create({прототип для данного объекта},{указывание поля для данного объекта})
 чтобы поле name было видно в цикле for..in(этот цикл прописан в script.js, 133 строка), можно использовать параметр enumerable:true
 чтобы значение поля можно было изменить, используем параметр writable:true
 чтобы удалить ключ, используем параметр configurable:true
 hasOwnPropety позволяет не пробегаться по прототипу и данный метод рекомендуется использовать тогда
  когда вы используете итерацию с помощью цикла for..in -->

    <!-- Async, await -->
    <!-- Async - это специальный синтаксический сахар, который позволяет нам более удобно программировать какие-то асинхронные вещи,
 для того чтобы исользовать оператор await, который обрабатывает и ждет завершения промиса, все что нам необходимо сделать это
 у родительской функции использовать префикс async далее мы используем оператор await перед промисом и тот результат
 который попадет в метод then мы можем синхронно получить в какую-то переменную и избавляемся от различных колбэков  
 -->

    <!-- Proxy -->
    <!-- Proxy - это специальный объект, который позволяет нам создать обертку над другим объектом и добавлять к нему дополнительные свойства и методы,
 для этого нам нужно использовать конструктор Proxy с двумя аргументами, первый это объект который нужно обернуть, а второй это объект с определенными свойствами и методами -->
    <!-- по сути это некоторый класс в JS позволяет создавать различный "ловушки" для объектов, классов, функций и т.д-->
    <!-- концепция прокси - реализация "ловушек", в которых переписываем функционал базовый -->
    <!-- методы прокси - get, set, has, deleteProperty, apply, construct, ownKeys

    get - позволяет изменять или получать свойство объекта
      receiver - это и есть прокси, который мы возвращаем (тот самый объект в котором мы ведем работу)
        get(target, prop, receiver){
        console.log('Getting...', prop);
        return target[prop];
    }
    set - позволяет изменять свойство объекта
        set(target, prop, value, receiver){
        console.log('Setting...', prop, value);
        target[prop] = value;
        return true;
    }  
    has - должен вернуть значение либо true, либо false, который будет говорить "есть ли такое поле в объекте"
    has(target, prop){
        return ['поле1 объекта', 'поле2 объекта', 'поле3 объекта', ...].includes(prop)
    }
    deleteProperty - ползволяет удалять какое-то свойство из объекта
        deleteProperty(target, prop){
        console.log('Deleting...' , prop);
        return delete target[prop];
    } 
    apply
        apply - отслеживание когда будет вызываться функция
        target - сама функция
        thisArg - контекст который будет использоваться внутри функции
        args - массив аргументов которые передаются в функцию (все параметры, которые передаем в функцию)
        apply(target, thisArg, args){
            return taget.apply(thisArg, args)
        } 
    construct
         construct - отслеживание когда будет создан новый экземпляр класса
         target - сам класс
         args - массив аргументов которые передаются в конструктор класса (все параметры, которые передаем в конструктор)
         construct(target, args){
            console.log('Creating...', args);
            return new target(...args);
        }
    ownKeys
        ownKeys - свойство которое говорит какие ключи действительно находятся внутри объекта
        -->
    <!-- Reflect - некоторый объект который позволяет более детально работать с объектами, например, получить его собственные ключи -->

    <!-- Генераторы. Symbol iterator, for of -->
    <!-- генераторы позволяют создавать итераторы, которые позволяют последовательно получать значения из последовательности -->
    <!-- Синтаксис генераторов: function* generatorName() {... } -->
     <!-- yield - выдает парционно выдает результат, который мы хотим выдать наружу
     При вызове метода Next запускает выполнение кода до ближайшей инструкции yield  -->
     <!-- Symbol.iterator - это специальный символ, который позволяет создавать собственные итераторы -->
     <!-- for...of - позволяет работать с итераторами, которые реализуют Symbol.iterator -->
</body>
<script src="script.js"></script>

</html>